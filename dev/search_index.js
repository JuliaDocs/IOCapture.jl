var documenterSearchIndex = {"docs":
[{"location":"#IOCapture","page":"Readme","title":"IOCapture","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"(Image: Version) (Image: Stable) (Image: Dev) (Image: CI) (Image: Coverage)","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Provides the IOCapture.capture(f) function which evaluates the function f, captures the standard output and standard error, and returns it as a string, together with the return value. For example:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"julia> c = IOCapture.capture() do\n           println(\"test\")\n           return 42\n       end;\n\njulia> c.value, c.output\n(42, \"test\\n\")","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"See the docstring for full documentation.","category":"page"},{"location":"#Known-limitations","page":"Readme","title":"Known limitations","text":"","category":"section"},{"location":"#Separately-stored-stdout-or-stderr-objects","page":"Readme","title":"Separately stored stdout or stderr objects","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"The capturing does not work properly if f prints to the stdout object that has been stored in a separate variable or object, e.g.:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"julia> const original_stdout = stdout;\n\njulia> c = IOCapture.capture() do\n           println(\"output to stdout\")\n           println(original_stdout, \"output to original stdout\")\n       end;\noutput to original stdout\n\njulia> c.output\n\"output to stdout\\n\"","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"Relatedly, it is possible to run into errors if the stdout or stderr objects from within a capture are being used in a subsequent capture or outside of the capture:","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"julia> c = IOCapture.capture() do\n           return stdout\n       end;\n\njulia> println(c.value, \"test\")\nERROR: IOError: stream is closed or unusable\nStacktrace:\n [1] check_open at ./stream.jl:328 [inlined]\n [2] uv_write_async(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:959\n ...","category":"page"},{"location":"","page":"Readme","title":"Readme","text":"This is because stdout and stderr within an capture actually refer to the temporary redirect streams which get cleaned up at the end of the capture call.","category":"page"},{"location":"#ANSI-color-/-escape-sequences","page":"Readme","title":"ANSI color / escape sequences","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"On Julia 1.5 and earlier, setting color to true has no effect, because the ability to set IOContext attributes on redirected streams was added in 1.6. I.e. on those older Julia versions the captured output will generally not contain ANSI color escape sequences.","category":"page"},{"location":"#Similar-packages","page":"Readme","title":"Similar packages","text":"","category":"section"},{"location":"","page":"Readme","title":"Readme","text":"Suppressor.jl provides similar functionality, but with a macro-based interface.","category":"page"},{"location":"autodocs/#IOCapture.capture-Tuple{Any}","page":"Docstrings","title":"IOCapture.capture","text":"IOCapture.capture(\n    f; rethrow=Any, color=false, passthrough=false, capture_buffer=IOBuffer(), io_context=[],\n)\n\nRuns the function f and captures the stdout and stderr outputs, without printing them in the terminal, unless passthrough=true.\n\nReturns an object with the following fields:\n\n.value :: Any: return value of the function, or the error exception object on error\n.output :: String: captured stdout and stderr\n.error :: Bool: set to true if f threw an error, false otherwise\n.backtrace :: Vector: array with the backtrace of the error if an error was thrown\n\nThe behaviour can be customized with the following keyword arguments:\n\nrethrow:\nWhen set to Any (default), capture will rethrow any exceptions thrown by evaluating f.\nTo only throw on a subset of possible exceptions pass the exception type instead, such as InterruptException. If multiple exception types may need to be thrown then pass a Union{...} of the types. Setting it to Union{} will capture all thrown exceptions. Captured exceptions will be returned via the .value field, and will also set .error and .backtrace accordingly.\ncolor: if set to true, capture inherits the :color property of stdout and stderr, which specifies whether ANSI color/escape codes are expected. This argument is only effective on Julia v1.6 and later.\npassthrough: if set to true, show the output as well as capturing it.\ncapture_buffer: The internal buffer used to capture the combined stdout and stderr.\nio_context: An optional vector of IOContext key/value pairs that are passed to the IOContext that wraps the redirected stdout and stderr streams. This only has an effect on Julia v1.6 and later.\n\nExtended help\n\ncapture works by temporarily redirecting the standard output and error streams (stdout and stderr) using redirect_stdout and redirect_stderr to a temporary capture_buffer, evaluate the function f and then restores the streams. Both the captured text output and the returned object get captured and returned:\n\njulia> c = IOCapture.capture() do\n           println(\"test\")\n       end;\n\njulia> c.output\n\"test\\n\"\n\nThis approach does have some limitations â€“ see the README for more information.\n\nIf passthrough=true, the redirected streams will also be passed through to the original standard output. As a result, the output from f would both be captured and shown on screen. Note that stdout and stderr are merged in the pass-through, and color is stripped unless the color option is set to true.\n\nExceptions. Normally, if f throws an exception, capture simply re-throws it with rethrow. However, by setting rethrow, it is also possible to capture errors, which then get returned via the .value field. Additionally, .error is set to true, to indicate that the function did not run normally, and the catch_backtrace of the exception is returned via .backtrace.\n\nAs mentioned above, it is also possible to set rethrow to InterruptException. This will make capture rethrow only InterruptExceptions. This is useful when you want to capture all the exceptions, but allow the user to interrupt the running code with Ctrl+C.\n\nCapture Buffer\n\nGiving a non-standard capture_buffer allows to dynamically process the captured output in arbitrary ways. For example, a custom buffer could truncate the capture of some very large output. The object passed as capture_buffer must implement two methods: Base.write(capture_buffer, bytes) and bytes = Base.take!(capture_buffer). When combined with passthrough, a custom capture_buffer will not affect the pass-through. Thus, for the example of a truncated capture, the pass-through would still show the full output.\n\nRecommended pattern. The recommended way to refer to capture is by fully qualifying the function name with IOCapture.capture. This is also why the package does not export the function. However, if a shorter name is desired, we recommend renaming the function when importing:\n\nusing IOcapture: capture as iocapture\n\nThis avoids the function name being too generic.\n\n\n\n\n\n","category":"method"}]
}
